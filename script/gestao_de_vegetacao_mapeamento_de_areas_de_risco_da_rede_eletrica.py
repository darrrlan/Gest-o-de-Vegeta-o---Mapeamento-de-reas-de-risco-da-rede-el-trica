# -*- coding: utf-8 -*-
"""Gestao de Vegetacao - Mapeamento de areas de risco da rede eletrica.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZSOLCrmGuO1xGqwc2OWC_N0wMUdu6w2I
"""

pip install seaborn

#Bibliotecas
import cv2
from google.colab import drive
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from PIL import Image

from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, roc_curve, auc, precision_recall_curve

from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

drive.mount('/content/drive')

def load_images_from_folders(root_folder):
    images = []
    labels = []
    label_mapping = {'Baixo risco': 0, 'Alto risco': 1}

    for label_folder in os.listdir(root_folder):
        label_path = os.path.join(root_folder, label_folder)
        
        if os.path.isdir(label_path):
            label = label_mapping.get(label_folder, -1) 
            for filename in os.listdir(label_path):
                img = cv2.imread(os.path.join(label_path, filename))
                if img is not None:
                    images.append(img)
                    labels.append(label)

    return images, labels

# Selecione entre RGB (True) e escala de cinza (False)
use_rgb = False

# Caminho para suas imagens no Google Drive
data_path = '/content/drive/MyDrive/Dataset - Gestão de Vegetação'

# Carregamento das imagens e rótulos
images, labels = load_images_from_folders(data_path) 

# Dividindo os dados em conjuntos de treinamento e teste
train_images, test_images, train_labels, test_labels = train_test_split(images, labels, test_size=0.2, random_state=42)

# Escolha entre RGB e escala de cinza
if use_rgb:

    train_images = np.array(train_images)
    test_images = np.array(test_images)
else:
   
    train_images = [cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) for img in train_images]
    test_images = [cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) for img in test_images]

    
    train_images = [cv2.resize(img, (128, 128)) for img in train_images]
    test_images = [cv2.resize(img, (128, 128)) for img in test_images]

    train_images = np.array(train_images) / 255.0  
    test_images = np.array(test_images) / 255.0  

# Convertendo os rótulos para numpy array
train_labels = np.array(train_labels)
test_labels = np.array(test_labels)

# Configuração do modelo CNN
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3 if use_rgb else 1)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(1, activation='sigmoid')
])

# Compilação do modelo
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Treinamento do modelo
history = model.fit(train_images, train_labels, epochs=10, batch_size=32, validation_split=0.1)

# Avaliação do modelo
test_loss, test_acc = model.evaluate(test_images, test_labels)
print(f'Acurácia do teste: {test_acc}')

# Predições no conjunto de teste (obtendo probabilidades)
predictions_probs = model.predict(test_images)

# Convertendo probabilidades para classes usando um limiar (por exemplo, 0.5)
predictions = (predictions_probs > 0.5).astype(int)

image_path = '/content/drive/MyDrive/Dataset - Gestão de Vegetação/Alto risco/2.png'

# Criando modelo para obter saídas intermediárias
layer_outputs = [layer.output for layer in model.layers[:-1]]  # Excluindo a camada densa de saída
activation_model = Model(inputs=model.input, outputs=layer_outputs)
activations = activation_model.predict(np.expand_dims(image, axis=0))

# Visualização da entrada, ativações de cada camada e saída final
num_layers = len(activations)  
num_cols = 4  
num_rows = (num_layers + num_cols - 1) // num_cols  

plt.figure(figsize=(15, 8), dpi = 500)

# Imagem de entrada
plt.subplot(num_rows, num_cols, 1)
plt.imshow(image[:, :, 0], cmap='gray')
plt.title('Input Image',fontsize=20)
plt.axis('off')

# Visualização das ativações de cada camada convolucional
for i in range(num_layers):
    activation_maps = activations[i][0, :, ]  
    num_filters = activation_maps.shape[-1]

    # Mostrar todos os mapas de ativação em uma grade
    for j in range(num_filters):
        subplot_num = i * num_cols + j + 2
        if subplot_num <= num_layers:  
            plt.subplot(num_rows, num_cols, subplot_num)
            plt.imshow(activation_maps[:, :, j], cmap='viridis')
            plt.title(f'Conv Layer {i + 1}, Filter {j + 1}',fontsize=20)
            plt.axis('off')

plt.tight_layout()
plt.show()

# Carregamento de uma única imagem para visualização
image_path = '/content/drive/MyDrive/Dataset - Gestão de Vegetação/Alto risco/2.png'
labels = '1'

# Criando modelo para obter saídas intermediárias
layer_outputs = [layer.output for layer in model.layers]  
activation_model = Model(inputs=model.input, outputs=layer_outputs)
activations = activation_model.predict(np.expand_dims(image, axis=0))

# Visualização da entrada, ativações de cada camada e saída final
num_layers = len(activations)
num_cols = 4  
num_rows = (num_layers + num_cols - 1) // num_cols  

plt.figure(figsize=(15, 8))

# Obtenha os valores da camada densa
dense_values = activations[-2][0, :]

# Crie um gráfico de barras para os valores
plt.subplot(num_rows, num_cols, 3)
plt.bar(range(len(dense_values)), dense_values, color='blue')
plt.title('Dense Layer Values')
plt.xlabel('Neurons')
plt.ylabel('Activation')

plt.tight_layout()
plt.show()

# Função para exibir imagens de previsões onde o valor verdadeiro é 1 e o valor previsto é 0 ou vice-versa
def exibir_imagens_predicoes_0_e_1(test_images, test_labels, predictions, num_imagens=2):
    indices_1_para_0 = np.where((test_labels == 1) & (predictions.flatten() == 0))[0]
    indices_0_para_1 = np.where((test_labels == 0) & (predictions.flatten() == 1))[0]


    num_rows = 2
    num_cols = num_imagens
    plt.figure(figsize=(15, 8))

    for i in range(min(num_imagens, len(indices_1_para_0))):
        idx_1_para_0 = indices_1_para_0[i]
        img_1_para_0 = test_images[idx_1_para_0]
        verdadeiro_rotulo_1_para_0 = "Alto Risco" if test_labels[idx_1_para_0] == 1 else "Baixo Risco"
        predito_rotulo_1_para_0 = "Alto Risco" if predictions[idx_1_para_0] == 1 else "Baixo Risco"

        idx_0_para_1 = indices_0_para_1[i]
        img_0_para_1 = test_images[idx_0_para_1]
        verdadeiro_rotulo_0_para_1 = "Alto Risco" if test_labels[idx_0_para_1] == 1 else "Baixo Risco"
        predito_rotulo_0_para_1 = "Alto Risco" if predictions[idx_0_para_1] == 1 else "Baixo Risco"

        # Subplot para 1 para 0
        plt.subplot(num_rows, num_cols, i + 1)
        plt.imshow(img_1_para_0, cmap='gray' if not use_rgb else None)
        plt.title(f"Verdadeiro: {verdadeiro_rotulo_1_para_0}\nPrevisto: {predito_rotulo_1_para_0}")
        plt.axis('off')

    for i in range(min(num_imagens, len(indices_0_para_1))):
        idx_0_para_1 = indices_0_para_1[i]
        img_0_para_1 = test_images[idx_0_para_1]
        verdadeiro_rotulo_0_para_1 = "Alto Risco" if test_labels[idx_0_para_1] == 1 else "Baixo Risco"
        predito_rotulo_0_para_1 = "Alto Risco" if predictions[idx_0_para_1] == 1 else "Baixo Risco"

        # Subplot para 0 para 1
        plt.subplot(num_rows, num_cols, i + num_imagens + 1)
        plt.imshow(img_0_para_1, cmap='gray' if not use_rgb else None)
        plt.title(f"Verdadeiro: {verdadeiro_rotulo_0_para_1}\nPrevisto: {predito_rotulo_0_para_1}")
        plt.axis('off')

    # Ajustes gerais para layout
    plt.tight_layout()
    plt.show()

# Exibir imagens para as previsões onde o valor verdadeiro é 1 e o valor previsto é 0, e vice-versa
exibir_imagens_predicoes_0_e_1(test_images, test_labels, predictions, num_imagens=2)

# Curva ROC
fpr, tpr, thresholds = roc_curve(test_labels, predictions_probs)
roc_auc = auc(fpr, tpr)

# Curva Precision-Recall
precision, recall, _ = precision_recall_curve(test_labels, predictions_probs)

# Criando subplots lado a lado
plt.figure(figsize=(16, 6))

# Subplot para a Curva ROC
plt.subplot(1, 2, 1)
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC Curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('Taxa de Falso Positivo')
plt.ylabel('Taxa de Verdadeiro Positivo')
plt.title('Curva ROC')
plt.legend()

# Subplot para a Curva Precision-Recall
plt.subplot(1, 2, 2)
plt.plot(recall, precision, color='darkgreen', lw=2, label='Precision-Recall Curve')
plt.xlabel('Revocação (Recall)')
plt.ylabel('Precisão')
plt.title('Curva Precision-Recall')
plt.legend()

# Ajustes gerais para layout
plt.tight_layout()
plt.show()

# Plotando gráfico único de treinamento e validação da evolução da perda e acurácia durante o treinamento
plt.figure(figsize=(12, 4))

# Gráfico da perda
ax1 = plt.subplot(1, 2, 1)
ax1.plot(history.history['loss'], label='Training Loss')
ax1.plot(history.history['val_loss'], label='Validation Loss', color='orange')
ax1.set_xlabel('Epoch')
ax1.set_ylabel('Loss')
ax1.set_title('Training and Validation Loss')
ax1.legend()

# Gráfico da acurácia
ax2 = plt.subplot(1, 2, 2)
ax2.plot(history.history['accuracy'], label='Training Accuracy')
ax2.plot(history.history['val_accuracy'], label='Validation Accuracy', color='orange')
ax2.set_xlabel('Epoch')
ax2.set_ylabel('Accuracy')
ax2.set_title('Training and Validation Accuracy')
ax2.legend()

plt.tight_layout()
plt.show()

# Identificando índices de previsões incorretas
misclassified_indices = np.where(test_labels != predictions)[0]

# Escolhendo uma imagem de alto risco e uma de baixo risco
high_risk_idx = np.where(predictions == 1)[0][0]
low_risk_idx = np.where(predictions == 0)[0][0]

high_risk_img = test_images[high_risk_idx]
low_risk_img = test_images[low_risk_idx]

# Exibindo histograma de barras para cada canal em uma única imagem para alto risco
plt.figure(figsize=(15, 5))

for i in range(high_risk_img.shape[2]):
    plt.subplot(1, 3, i+1)
    hist_channel = cv2.calcHist([high_risk_img], [i], None, [256], [0, 256])
    plt.bar(np.arange(256), hist_channel.flatten(), color=colors[i], alpha=0.7)
    plt.title(f'Channel {i}')
    plt.xlabel('Pixel Value')
    plt.ylabel('Frequency')

plt.suptitle('Channels Histogram - High Risk Image')
plt.show()

# Exibindo histograma de barras para cada canal em uma única imagem para baixo risco
plt.figure(figsize=(15, 5))

for i in range(low_risk_img.shape[2]):
    plt.subplot(1, 3, i+1)
    hist_channel = cv2.calcHist([low_risk_img], [i], None, [256], [0, 256])
    plt.bar(np.arange(256), hist_channel.flatten(), color=colors[i], alpha=0.7)
    plt.title(f'Channel {i}')
    plt.xlabel('Pixel Value')
    plt.ylabel('Frequency')

plt.suptitle('Channels Histogram - Low Risk Image')
plt.show()

# Matriz de confusão
conf_matrix = confusion_matrix(test_labels, predictions)

# Gráfico da matriz de confusão
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['Baixo Risco', 'Alto risco'], yticklabels=['Baixo Risco', 'Alto risco'])
plt.title('Matriz de Confusão')
plt.xlabel('Previsto')
plt.ylabel('Verdadeiro')
plt.show()